#!/usr/bin/env python3
"""
BandLang Musical Compiler V2 - Sistema Musical + Multitrack
Preserva o multitracking enquanto oferece notação musical intuitiva
"""

import sys
import re

class MusicalCompilerV2:
    def __init__(self):
        self.current_bpm = 120
        self.current_timesig = (4, 4)
        self.default_duration = "quarter"
        
        # Mapeamento de valores musicais para ticks (480 ticks = 1 beat)
        self.duration_map = {
            # Valores tradicionais
            "whole": 1920,      # Semibreve (4 beats)
            "half": 960,        # Mínima (2 beats)
            "quarter": 480,     # Semínima (1 beat)
            "eighth": 240,      # Colcheia (0.5 beat)
            "sixteenth": 120,   # Semicolcheia (0.25 beat)
            "thirtysecond": 60, # Fusa (0.125 beat)
            
            # Símbolos curtos
            "w": 1920,    # whole
            "h": 960,     # half  
            "q": 480,     # quarter
            "e": 240,     # eighth
            "s": 120,     # sixteenth
            "t": 60,      # thirtysecond
            
            # Valores pontuados (1.5x)
            "quarter.": 720,    # Semínima pontuada
            "half.": 1440,      # Mínima pontuada
            "eighth.": 360,     # Colcheia pontuada
            "q.": 720,          # quarter.
            "h.": 1440,         # half.
            "e.": 360,          # eighth.
            
            # Frações úteis
            "2beat": 960,       # 2 tempos
            "3beat": 1440,      # 3 tempos
            "4beat": 1920,      # 4 tempos (compasso completo em 4/4)
        }
    
    def note_to_midi(self, note_str):
        """Converte nota musical para MIDI"""
        note_map = {
            "C": 0, "C#": 1, "Db": 1,
            "D": 2, "D#": 3, "Eb": 3,
            "E": 4,
            "F": 5, "F#": 6, "Gb": 6,
            "G": 7, "G#": 8, "Ab": 8,
            "A": 9, "A#": 10, "Bb": 10,
            "B": 11
        }
        
        match = re.match(r"([A-G][#b]?)(\d)", note_str)
        if not match:
            raise ValueError(f"Invalid note format: {note_str}")
        
        note_name = match.group(1)
        octave = int(match.group(2))
        
        midi_note = note_map[note_name] + (octave + 1) * 12
        return midi_note
    
    def parse_duration(self, duration_str):
        """Converte duração musical para ticks"""
        if not duration_str:
            duration_str = self.default_duration
            
        # Procurar na tabela de durações musicais
        if duration_str in self.duration_map:
            return self.duration_map[duration_str]
        
        # Fallback para milissegundos (compatibilidade)
        if duration_str.endswith("ms"):
            ms = int(duration_str[:-2])
            ms_per_beat = 60000 / self.current_bpm
            return int((ms / ms_per_beat) * 480)
        elif duration_str.endswith("s"):
            seconds = float(duration_str[:-1])
            ms = int(seconds * 1000)
            ms_per_beat = 60000 / self.current_bpm
            return int((ms / ms_per_beat) * 480)
        
        # Padrão se não reconhecer
        return self.duration_map[self.default_duration]
    
    def get_track_id(self, instrument, instruments):
        """Determina track ID baseado no instrumento"""
        if instrument in instruments:
            instr_type = instruments[instrument]
            if instr_type in ['bass', 'baixo', 'bass808']:
                return 0
            elif instr_type in ['guitar', 'guitarra', 'synth', 'piano', 'sanfona']:
                return 1
            elif instr_type == 'drums':
                return 2
        return 0  # Default to bass
    
    def compile_bandlang(self, content):
        """Compila BandLang para GBASM preservando multitrack"""
        lines = [line.strip() for line in content.split('\n') if line.strip()]
        gbasm = []
        
        # Header
        gbasm.append("; Generated by Musical BandLang Compiler V2")
        gbasm.append("; Multitrack-preserving musical timing system")
        gbasm.append("")
        
        # Parse configurações globais
        instruments = {}
        
        for line in lines:
            line = line.rstrip(';').strip()
            
            # BPM
            if line.startswith('bpm'):
                bpm_match = re.search(r'bpm\s+(\d+)', line)
                if bpm_match:
                    self.current_bpm = int(bpm_match.group(1))
                    gbasm.append(f"SET_TEMPO {self.current_bpm}")
            
            # Time signature
            elif line.startswith('timesig'):
                timesig_match = re.search(r'timesig\s+(\d+)/(\d+)', line)
                if timesig_match:
                    num = int(timesig_match.group(1))
                    den = int(timesig_match.group(2))
                    self.current_timesig = (num, den)
                    gbasm.append(f"SET_TS {num} {den}")
            
            # Default duration
            elif line.startswith('default_duration'):
                dur_match = re.search(r'default_duration\s+(\w+)', line)
                if dur_match:
                    self.default_duration = dur_match.group(1)
                    gbasm.append(f"; Default duration: {self.default_duration}")
            
            # Instruments
            elif line.startswith('instrument'):
                instr_match = re.search(r'instrument\s+(\w+):\s*(\w+)', line)
                if instr_match:
                    var_name = instr_match.group(1)
                    instr_type = instr_match.group(2)
                    instruments[var_name] = instr_type
                    gbasm.append(f"; Instrument: {var_name} -> {instr_type}")
        
        gbasm.append("")
        
        # Parse loops e statements (SEM auto-advance para preservar multitrack)
        loop_counter = 0
        
        i = 0
        while i < len(lines):
            line = lines[i].rstrip(';').strip()
            
            if line.startswith('loop'):
                loop_match = re.search(r'loop\s+(\d+)\s*\{', line)
                if loop_match:
                    count = int(loop_match.group(1))
                    label = f"LOOP_{loop_counter}"
                    loop_counter += 1
                    
                    gbasm.append(f"LOAD R1 {count}")
                    gbasm.append(f":{label}")
                    
                    # Parse loop body
                    i += 1
                    while i < len(lines) and not lines[i].strip().startswith('}'):
                        body_line = lines[i].rstrip(';').strip()
                        if body_line:
                            gbasm.extend(self.parse_statement(body_line, instruments))
                        i += 1
                    
                    gbasm.append(f"DECJNZ R1 {label}")
            
            elif line.startswith('play') or line.startswith('wait'):
                gbasm.extend(self.parse_statement(line, instruments))
            
            i += 1
        
        gbasm.append("HALT")
        return '\n'.join(gbasm)
    
    def parse_statement(self, line, instruments):
        """Parse individual statements preservando multitrack"""
        gbasm = []
        
        # Play note - aceita duração musical OU usa default
        note_patterns = [
            # Com duração especificada (musical ou ms)
            r'play\s+(\w+):\s*note\s*"([A-G][#b]?\d)",\s*(\d+),\s*(\w+\.?|[\d.]+\w*)',
            # Sem duração (usa default)
            r'play\s+(\w+):\s*note\s*"([A-G][#b]?\d)",\s*(\d+)'
        ]
        
        for pattern in note_patterns:
            note_match = re.search(pattern, line)
            if note_match:
                instrument = note_match.group(1)
                note_str = note_match.group(2)
                velocity = int(note_match.group(3))
                duration_str = note_match.group(4) if len(note_match.groups()) >= 4 else None
                
                track_id = self.get_track_id(instrument, instruments)
                midi_note = self.note_to_midi(note_str)
                duration_ticks = self.parse_duration(duration_str)
                
                gbasm.append(f"TRACK {track_id}")
                gbasm.append(f"NOTE {midi_note} {velocity} {duration_ticks}")
                
                return gbasm
        
        # Play chord - aceita duração musical OU usa default
        chord_patterns = [
            # Com duração especificada
            r'play\s+(\w+):\s*chord\s*\[(.*?)\],\s*(\d+),\s*(\w+\.?|[\d.]+\w*)',
            # Sem duração (usa default)
            r'play\s+(\w+):\s*chord\s*\[(.*?)\],\s*(\d+)'
        ]
        
        for pattern in chord_patterns:
            chord_match = re.search(pattern, line)
            if chord_match:
                instrument = chord_match.group(1)
                pitches_str = chord_match.group(2)
                velocity = int(chord_match.group(3))
                duration_str = chord_match.group(4) if len(chord_match.groups()) >= 4 else None
                
                track_id = self.get_track_id(instrument, instruments)
                pitches = [p.strip().strip('"') for p in pitches_str.split(',')]
                midi_pitches = [self.note_to_midi(p) for p in pitches]
                duration_ticks = self.parse_duration(duration_str)
                
                gbasm.append(f"TRACK {track_id}")
                gbasm.append(f"CHORD {len(midi_pitches)} {' '.join(map(str, midi_pitches))} {velocity} {duration_ticks}")
                
                return gbasm
        
        # Play drums - aceita duração musical OU usa default
        drum_patterns = [
            # Com duração especificada
            r'play\s+drums:\s*(kick|snare|hihat),\s*(\d+),\s*(\w+\.?|[\d.]+\w*)',
            # Sem duração (usa default)
            r'play\s+drums:\s*(kick|snare|hihat),\s*(\d+)'
        ]
        
        for pattern in drum_patterns:
            drum_match = re.search(pattern, line)
            if drum_match:
                drum_type = drum_match.group(1)
                velocity = int(drum_match.group(2))
                duration_str = drum_match.group(3) if len(drum_match.groups()) >= 3 else None
                
                drum_type_id = {"kick": 0, "snare": 1, "hihat": 2}[drum_type]
                duration_ticks = self.parse_duration(duration_str)
                
                gbasm.append(f"TRACK 2")  # Drums always track 2
                gbasm.append(f"DRUM {drum_type_id} {velocity} {duration_ticks}")
                
                return gbasm
        
        # Wait - suporta duração musical
        wait_match = re.search(r'wait\s+(\w+\.?|[\d.]+\w*)', line)
        if wait_match:
            duration_str = wait_match.group(1)
            duration_ticks = self.parse_duration(duration_str)
            gbasm.append(f"WAIT {duration_ticks}")
            return gbasm
        
        # Comentário não reconhecido
        gbasm.append(f"; {line}")
        return gbasm

def main():
    if len(sys.argv) != 3:
        print("Usage: python musical_compiler_v2.py <input.band> <output.gbasm>")
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        compiler = MusicalCompilerV2()
        gbasm = compiler.compile_bandlang(content)
        
        with open(output_file, 'w') as f:
            f.write(gbasm)
        
        print(f"✓ Musical V2 compilation: {input_file} -> {output_file}")
        print(f"✓ BPM: {compiler.current_bpm}")
        print(f"✓ Default duration: {compiler.default_duration}")
        print(f"✓ Multitrack-preserving mode")
        
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
