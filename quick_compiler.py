#!/usr/bin/env python3
"""
Quick BandLang to GBASM compiler
Parses the new music files and generates correct GBASM
"""

import re
import sys

def pitch_to_midi(pitch):
    """Convert pitch string like 'E2' to MIDI note number"""
    note_map = {
        'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,
        'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8,
        'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
    }
    
    if len(pitch) < 2:
        return 60  # Middle C
    
    note = pitch[:-1]
    octave = int(pitch[-1])
    
    if note not in note_map:
        return 60
    
    return (octave + 1) * 12 + note_map[note]

def duration_to_ticks(duration_str):
    """Convert duration like '500ms' to ticks"""
    if 'ms' in duration_str:
        ms = int(duration_str.replace('ms', ''))
        return int(ms / 1.04)  # ~1.04ms per tick at 120 BPM
    elif 's' in duration_str:
        s = int(duration_str.replace('s', ''))
        return s * 480
    elif 'ticks' in duration_str:
        return int(duration_str.replace('ticks', ''))
    return 480

def get_track_id(instrument):
    """Get track ID for instrument"""
    if instrument in ['bass', 'baixo', 'bass808']:
        return 0
    elif instrument in ['guitar', 'guitarra', 'synth', 'piano']:
        return 1
    elif instrument == 'drums':
        return 2
    return 0

def get_drum_id(drum_type):
    """Get drum ID for drum type"""
    if drum_type == 'kick':
        return 0
    elif drum_type == 'snare':
        return 1
    elif drum_type == 'hihat':
        return 2
    return 0

def parse_bandlang(content):
    """Parse BandLang content and generate GBASM"""
    lines = content.split('\n')
    gbasm = []
    
    # Header
    gbasm.append("; Generated by Quick BandLang Compiler")
    gbasm.append("; Complex music program")
    gbasm.append("")
    
    # Parse BPM and time signature
    for line in lines:
        if line.strip().startswith('bpm'):
            bpm = re.search(r'bpm\s+(\d+)', line)
            if bpm:
                gbasm.append(f"SET_TEMPO {bpm.group(1)}")
        elif line.strip().startswith('timesig'):
            timesig = re.search(r'timesig\s+(\d+)/(\d+)', line)
            if timesig:
                gbasm.append(f"SET_TS {timesig.group(1)} {timesig.group(2)}")
    
    gbasm.append("")
    
    # Parse instruments (store for reference)
    instruments = {}
    for line in lines:
        instr_match = re.search(r'instrument\s+(\w+):\s*(\w+)', line)
        if instr_match:
            var_name = instr_match.group(1)
            instr_type = instr_match.group(2)
            instruments[var_name] = instr_type
            gbasm.append(f"; Instrument: {var_name} : {instr_type}")
    
    # Parse loops and statements
    in_loop = False
    loop_counter = 0
    loop_count = 1
    
    for line in lines:
        line = line.strip()
        
        # Loop start
        loop_match = re.search(r'loop\s+(\d+)\s*\{', line)
        if loop_match:
            loop_count = int(loop_match.group(1))
            gbasm.append(f"; Loop statement")
            gbasm.append(f"LOAD R1 {loop_count}")
            gbasm.append(f":LOOP_{loop_counter}")
            in_loop = True
            continue
            
        # Loop end
        if line == '}' and in_loop:
            gbasm.append(f"DECJNZ R1 LOOP_{loop_counter}")
            loop_counter += 1
            in_loop = False
            continue
        
        # Play note
        note_match = re.search(r'play\s+(\w+):\s*note\s+"([^"]+)",\s*(\d+),\s*(\w+)', line)
        if note_match:
            instr_var = note_match.group(1)
            pitch = note_match.group(2)
            velocity = int(note_match.group(3))
            duration = note_match.group(4)
            
            instr_type = instruments.get(instr_var, instr_var)
            track_id = get_track_id(instr_type)
            midi_note = pitch_to_midi(pitch)
            ticks = duration_to_ticks(duration)
            
            gbasm.append(f"TRACK {track_id}")
            gbasm.append(f"NOTE {midi_note} {velocity} {ticks}")
            continue
        
        # Play chord
        chord_match = re.search(r'play\s+(\w+):\s*chord\s+\[([^\]]+)\],\s*(\d+),\s*(\w+)', line)
        if chord_match:
            instr_var = chord_match.group(1)
            pitches_str = chord_match.group(2)
            velocity = int(chord_match.group(3))
            duration = chord_match.group(4)
            
            # Parse pitches
            pitches = [p.strip().strip('"') for p in pitches_str.split(',')]
            midi_notes = [pitch_to_midi(p) for p in pitches]
            
            instr_type = instruments.get(instr_var, instr_var)
            track_id = get_track_id(instr_type)
            ticks = duration_to_ticks(duration)
            
            gbasm.append(f"TRACK {track_id}")
            gbasm.append(f"CHORD {len(midi_notes)} {' '.join(map(str, midi_notes))} {velocity} {ticks}")
            continue
        
        # Play drum
        drum_match = re.search(r'play\s+drums:\s*(\w+),\s*(\d+),\s*(\w+)', line)
        if drum_match:
            drum_type = drum_match.group(1)
            velocity = int(drum_match.group(2))
            duration = drum_match.group(3)
            
            drum_id = get_drum_id(drum_type)
            ticks = duration_to_ticks(duration)
            
            gbasm.append("TRACK 2")
            gbasm.append(f"DRUM {drum_id} {velocity} {ticks}")
            continue
        
        # Wait
        wait_match = re.search(r'wait\s+(\w+)', line)
        if wait_match:
            duration = wait_match.group(1)
            ticks = duration_to_ticks(duration)
            gbasm.append(f"WAIT {ticks}")
            continue
    
    gbasm.append("")
    gbasm.append("HALT")
    
    return '\n'.join(gbasm)

def main():
    if len(sys.argv) != 3:
        print("Usage: python quick_compiler.py <input.band> <output.gbasm>")
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        gbasm = parse_bandlang(content)
        
        with open(output_file, 'w') as f:
            f.write(gbasm)
        
        print(f"âœ“ Compiled {input_file} -> {output_file}")
        
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
