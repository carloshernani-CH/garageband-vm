#!/usr/bin/env python3
"""
BandLang Pattern Compiler - Sistema Musical + Patterns Rítmicos Precisos
Adiciona pattern sequencing ao sistema musical existente
"""

import sys
import re

class PatternCompiler:
    def __init__(self):
        self.current_bpm = 120
        self.current_timesig = (4, 4)
        self.default_duration = "quarter"
        self.patterns = {}  # Armazena patterns definidos
        
        # Mapeamento de valores musicais para ticks (480 ticks = 1 beat)
        self.duration_map = {
            # Valores tradicionais
            "whole": 1920,      # Semibreve (4 beats)
            "half": 960,        # Mínima (2 beats)
            "quarter": 480,     # Semínima (1 beat)
            "eighth": 240,      # Colcheia (0.5 beat)
            "sixteenth": 120,   # Semicolcheia (0.25 beat)
            "thirtysecond": 60, # Fusa (0.125 beat)
            
            # Símbolos curtos
            "w": 1920, "h": 960, "q": 480, "e": 240, "s": 120, "t": 60,
            
            # Valores pontuados (1.5x)
            "quarter.": 720, "half.": 1440, "eighth.": 360,
            "q.": 720, "h.": 1440, "e.": 360,
            
            # Frações úteis
            "2beat": 960, "3beat": 1440, "4beat": 1920,
        }
        
        # Resoluções para patterns
        self.resolution_map = {
            "whole": 1920,
            "half": 960,
            "quarter": 480,
            "eighth": 240,      # Padrão para patterns (colcheia)
            "sixteenth": 120,   # Para hi-hats rápidos
            "thirtysecond": 60, # Para rolls
        }
    
    def note_to_midi(self, note_str):
        """Converte nota musical para MIDI"""
        note_map = {
            "C": 0, "C#": 1, "Db": 1,
            "D": 2, "D#": 3, "Eb": 3,
            "E": 4,
            "F": 5, "F#": 6, "Gb": 6,
            "G": 7, "G#": 8, "Ab": 8,
            "A": 9, "A#": 10, "Bb": 10,
            "B": 11
        }
        
        match = re.match(r"([A-G][#b]?)(\d)", note_str)
        if not match:
            raise ValueError(f"Invalid note format: {note_str}")
        
        note_name = match.group(1)
        octave = int(match.group(2))
        
        midi_note = note_map[note_name] + (octave + 1) * 12
        return midi_note
    
    def parse_duration(self, duration_str):
        """Converte duração musical para ticks"""
        if not duration_str:
            duration_str = self.default_duration
            
        if duration_str in self.duration_map:
            return self.duration_map[duration_str]
        
        # Compatibilidade com ms
        if duration_str.endswith("ms"):
            ms = int(duration_str[:-2])
            ms_per_beat = 60000 / self.current_bpm
            return int((ms / ms_per_beat) * 480)
        elif duration_str.endswith("s"):
            seconds = float(duration_str[:-1])
            ms = int(seconds * 1000)
            ms_per_beat = 60000 / self.current_bpm
            return int((ms / ms_per_beat) * 480)
        
        return self.duration_map[self.default_duration]
    
    def parse_pattern_steps(self, steps_str):
        """Parse pattern steps: '1-0-127-0-0-60-1-0'"""
        steps = []
        for step in steps_str.split('-'):
            step = step.strip()
            if step == '0':
                steps.append(0)  # Mudo
            else:
                velocity = int(step)
                steps.append(min(127, max(1, velocity)))  # Clamp entre 1-127
        return steps
    
    def get_track_id(self, instrument, instruments):
        """Determina track ID baseado no instrumento"""
        if instrument in instruments:
            instr_type = instruments[instrument]
            if instr_type in ['bass', 'baixo', 'bass808']:
                return 0
            elif instr_type in ['guitar', 'guitarra', 'synth', 'piano', 'sanfona']:
                return 1
            elif instr_type == 'drums':
                return 2
        return 0
    
    def compile_bandlang(self, content):
        """Compila BandLang para GBASM com suporte a patterns"""
        lines = [line.strip() for line in content.split('\n') if line.strip()]
        gbasm = []
        
        # Header
        gbasm.append("; Generated by BandLang Pattern Compiler")
        gbasm.append("; Musical notation + Rhythmic patterns")
        gbasm.append("")
        
        # Parse configurações globais e patterns
        instruments = {}
        
        i = 0
        while i < len(lines):
            line = lines[i].rstrip(';').strip()
            
            # BPM
            if line.startswith('bpm'):
                bpm_match = re.search(r'bpm\s+(\d+)', line)
                if bpm_match:
                    self.current_bpm = int(bpm_match.group(1))
                    gbasm.append(f"SET_TEMPO {self.current_bpm}")
            
            # Time signature
            elif line.startswith('timesig'):
                timesig_match = re.search(r'timesig\s+(\d+)/(\d+)', line)
                if timesig_match:
                    num = int(timesig_match.group(1))
                    den = int(timesig_match.group(2))
                    self.current_timesig = (num, den)
                    gbasm.append(f"SET_TS {num} {den}")
            
            # Default duration
            elif line.startswith('default_duration'):
                dur_match = re.search(r'default_duration\s+(\w+)', line)
                if dur_match:
                    self.default_duration = dur_match.group(1)
                    gbasm.append(f"; Default duration: {self.default_duration}")
            
            # Instruments
            elif line.startswith('instrument'):
                instr_match = re.search(r'instrument\s+(\w+):\s*(\w+)', line)
                if instr_match:
                    var_name = instr_match.group(1)
                    instr_type = instr_match.group(2)
                    instruments[var_name] = instr_type
                    gbasm.append(f"; Instrument: {var_name} -> {instr_type}")
            
            # Pattern definition
            elif line.startswith('pattern'):
                pattern_match = re.search(r'pattern\s+(\w+)\s*\{', line)
                if pattern_match:
                    pattern_name = pattern_match.group(1)
                    i += 1
                    pattern_data = self.parse_pattern_block(lines, i, pattern_name)
                    i = pattern_data['end_index']
                    self.patterns[pattern_name] = pattern_data['pattern']
                    gbasm.append(f"; Pattern defined: {pattern_name}")
            
            i += 1
        
        gbasm.append("")
        
        # Parse loops e statements
        loop_counter = 0
        
        i = 0
        while i < len(lines):
            line = lines[i].rstrip(';').strip()
            
            if line.startswith('loop'):
                loop_match = re.search(r'loop\s+(\d+)\s*\{', line)
                if loop_match:
                    count = int(loop_match.group(1))
                    label = f"LOOP_{loop_counter}"
                    loop_counter += 1
                    
                    gbasm.append(f"LOAD R1 {count}")
                    gbasm.append(f":{label}")
                    
                    # Parse loop body
                    i += 1
                    while i < len(lines) and not lines[i].strip().startswith('}'):
                        body_line = lines[i].rstrip(';').strip()
                        if body_line and not body_line.startswith('pattern'):
                            gbasm.extend(self.parse_statement(body_line, instruments))
                        i += 1
                    
                    gbasm.append(f"DECJNZ R1 {label}")
            
            elif line.startswith('play') or line.startswith('wait'):
                gbasm.extend(self.parse_statement(line, instruments))
            
            i += 1
        
        gbasm.append("HALT")
        return '\n'.join(gbasm)
    
    def parse_pattern_block(self, lines, start_index, pattern_name):
        """Parse um bloco de pattern definition"""
        pattern = {
            'steps': 16,  # Default: 16 steps
            'resolution': 'eighth',  # Default: colcheia por step
            'tracks': {}
        }
        
        i = start_index
        while i < len(lines) and not lines[i].strip().startswith('}'):
            line = lines[i].rstrip(';').strip()
            
            # Steps
            steps_match = re.search(r'steps\s+(\d+)', line)
            if steps_match:
                pattern['steps'] = int(steps_match.group(1))
            
            # Resolution
            res_match = re.search(r'resolution\s+(\w+)', line)
            if res_match:
                pattern['resolution'] = res_match.group(1)
            
            # Drum patterns
            drum_match = re.search(r'(kick|snare|hihat):\s*"([^"]+)"', line)
            if drum_match:
                drum_type = drum_match.group(1)
                steps_str = drum_match.group(2)
                pattern['tracks'][drum_type] = self.parse_pattern_steps(steps_str)
            
            i += 1
        
        return {'pattern': pattern, 'end_index': i}
    
    def generate_pattern_gbasm(self, pattern_name):
        """Gera GBASM para um pattern"""
        if pattern_name not in self.patterns:
            return [f"; Error: Pattern {pattern_name} not found"]
        
        pattern = self.patterns[pattern_name]
        gbasm = []
        
        # Calcula duração de cada step baseado na resolução
        resolution = pattern['resolution']
        step_duration = self.resolution_map.get(resolution, 240)  # Default: eighth
        
        gbasm.append(f"; Pattern: {pattern_name} ({pattern['steps']} steps, {resolution} resolution)")
        
        # Gera eventos para cada step
        for step_idx in range(pattern['steps']):
            step_time = step_idx * step_duration
            has_events = False
            
            # Verifica se há eventos neste step
            for drum_type, steps in pattern['tracks'].items():
                if step_idx < len(steps) and steps[step_idx] > 0:
                    has_events = True
                    break
            
            if has_events:
                gbasm.append(f"; Step {step_idx + 1}")
                
                # Gera eventos para cada drum que toca neste step
                for drum_type, steps in pattern['tracks'].items():
                    if step_idx < len(steps) and steps[step_idx] > 0:
                        velocity = steps[step_idx]
                        drum_id = {"kick": 0, "snare": 1, "hihat": 2}[drum_type]
                        
                        gbasm.append(f"TRACK 2")
                        gbasm.append(f"DRUM {drum_id} {velocity} {step_duration}")
                
                # Avança para o próximo step
                gbasm.append(f"WAIT {step_duration}")
            else:
                # Step vazio, só avança o tempo
                gbasm.append(f"WAIT {step_duration}")
        
        return gbasm
    
    def parse_statement(self, line, instruments):
        """Parse individual statements (incluindo patterns)"""
        gbasm = []
        
        # Play pattern
        pattern_match = re.search(r'play\s+pattern\s+(\w+)', line)
        if pattern_match:
            pattern_name = pattern_match.group(1)
            return self.generate_pattern_gbasm(pattern_name)
        
        # Play note - aceita duração musical OU usa default
        note_patterns = [
            r'play\s+(\w+):\s*note\s*"([A-G][#b]?\d)",\s*(\d+),\s*(\w+\.?|[\d.]+\w*)',
            r'play\s+(\w+):\s*note\s*"([A-G][#b]?\d)",\s*(\d+)'
        ]
        
        for pattern in note_patterns:
            note_match = re.search(pattern, line)
            if note_match:
                instrument = note_match.group(1)
                note_str = note_match.group(2)
                velocity = int(note_match.group(3))
                duration_str = note_match.group(4) if len(note_match.groups()) >= 4 else None
                
                track_id = self.get_track_id(instrument, instruments)
                midi_note = self.note_to_midi(note_str)
                duration_ticks = self.parse_duration(duration_str)
                
                gbasm.append(f"TRACK {track_id}")
                gbasm.append(f"NOTE {midi_note} {velocity} {duration_ticks}")
                return gbasm
        
        # Play chord
        chord_patterns = [
            r'play\s+(\w+):\s*chord\s*\[(.*?)\],\s*(\d+),\s*(\w+\.?|[\d.]+\w*)',
            r'play\s+(\w+):\s*chord\s*\[(.*?)\],\s*(\d+)'
        ]
        
        for pattern in chord_patterns:
            chord_match = re.search(pattern, line)
            if chord_match:
                instrument = chord_match.group(1)
                pitches_str = chord_match.group(2)
                velocity = int(chord_match.group(3))
                duration_str = chord_match.group(4) if len(chord_match.groups()) >= 4 else None
                
                track_id = self.get_track_id(instrument, instruments)
                pitches = [p.strip().strip('"') for p in pitches_str.split(',')]
                midi_pitches = [self.note_to_midi(p) for p in pitches]
                duration_ticks = self.parse_duration(duration_str)
                
                gbasm.append(f"TRACK {track_id}")
                gbasm.append(f"CHORD {len(midi_pitches)} {' '.join(map(str, midi_pitches))} {velocity} {duration_ticks}")
                return gbasm
        
        # Play drums individuais
        drum_patterns = [
            r'play\s+drums:\s*(kick|snare|hihat),\s*(\d+),\s*(\w+\.?|[\d.]+\w*)',
            r'play\s+drums:\s*(kick|snare|hihat),\s*(\d+)'
        ]
        
        for pattern in drum_patterns:
            drum_match = re.search(pattern, line)
            if drum_match:
                drum_type = drum_match.group(1)
                velocity = int(drum_match.group(2))
                duration_str = drum_match.group(3) if len(drum_match.groups()) >= 3 else None
                
                drum_type_id = {"kick": 0, "snare": 1, "hihat": 2}[drum_type]
                duration_ticks = self.parse_duration(duration_str)
                
                gbasm.append(f"TRACK 2")
                gbasm.append(f"DRUM {drum_type_id} {velocity} {duration_ticks}")
                return gbasm
        
        # Wait
        wait_match = re.search(r'wait\s+(\w+\.?|[\d.]+\w*)', line)
        if wait_match:
            duration_str = wait_match.group(1)
            duration_ticks = self.parse_duration(duration_str)
            gbasm.append(f"WAIT {duration_ticks}")
            return gbasm
        
        # Comentário não reconhecido
        gbasm.append(f"; {line}")
        return gbasm

def main():
    if len(sys.argv) != 3:
        print("Usage: python pattern_compiler.py <input.band> <output.gbasm>")
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        compiler = PatternCompiler()
        gbasm = compiler.compile_bandlang(content)
        
        with open(output_file, 'w') as f:
            f.write(gbasm)
        
        print(f"✓ Pattern compilation: {input_file} -> {output_file}")
        print(f"✓ BPM: {compiler.current_bpm}")
        print(f"✓ Default duration: {compiler.default_duration}")
        print(f"✓ Patterns defined: {list(compiler.patterns.keys())}")
        
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
