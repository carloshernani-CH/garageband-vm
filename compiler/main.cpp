#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <cmath>
#include "ast.hpp"

// Forward declarations from parser
extern FILE* yyin;
extern int yyparse();
extern SimpleNode* root;

// Pitch string to MIDI note conversion
int pitchToMIDI(const std::string& pitch) {
    static std::map<std::string, int> noteMap = {
        {"C", 0}, {"C#", 1}, {"Db", 1}, {"D", 2}, {"D#", 3}, {"Eb", 3},
        {"E", 4}, {"F", 5}, {"F#", 6}, {"Gb", 6}, {"G", 7}, {"G#", 8}, 
        {"Ab", 8}, {"A", 9}, {"A#", 10}, {"Bb", 10}, {"B", 11}
    };
    
    if (pitch.length() < 2) return 60; // Default middle C
    
    std::string note = pitch.substr(0, pitch.length() - 1);
    int octave = std::stoi(pitch.substr(pitch.length() - 1));
    
    if (noteMap.find(note) == noteMap.end()) return 60;
    
    return (octave + 1) * 12 + noteMap[note];
}

// Duration to ticks conversion (480 ticks per beat at any BPM)
int durationToTicks(const std::string& durationStr) {
    if (durationStr.find("ms") != std::string::npos) {
        int ms = std::stoi(durationStr.substr(0, durationStr.find("ms")));
        // Convert ms to ticks: 480 ticks per beat, 120 BPM default
        // 1 beat = 500ms at 120 BPM, so 1 tick = 500/480 ≈ 1.04ms
        return static_cast<int>(ms / 1.04);
    } else if (durationStr.find("s") != std::string::npos) {
        int s = std::stoi(durationStr.substr(0, durationStr.find("s")));
        return s * 480; // 480 ticks per second at 120 BPM
    } else if (durationStr.find("ticks") != std::string::npos) {
        return std::stoi(durationStr.substr(0, durationStr.find("ticks")));
    }
    return 480; // Default 1 beat
}

// Track name to ID mapping
int getTrackID(const std::string& instrument) {
    if (instrument == "bass" || instrument == "baixo") return 0;
    if (instrument == "guitar" || instrument == "guitarra") return 1;
    if (instrument == "drums") return 2;
    return 0; // Default bass
}

// Drum type to ID mapping
int getDrumID(const std::string& drumType) {
    if (drumType == "kick") return 0;
    if (drumType == "snare") return 1;
    if (drumType == "hihat") return 2;
    return 0; // Default kick
}

// Generate GBASM from AST
std::string generateGBASM(SimpleNode* node) {
    if (!node) return "";
    
    std::string result;
    
    if (node->type == "program") {
        result += "; Generated by GarageBand Compiler\n";
        result += "; Advanced music program\n\n";
        
        // Process header
        if (node->children.size() > 0 && node->children[0]->type == "header") {
            for (auto child : node->children[0]->children) {
                if (child->type == "bpm") {
                    result += "SET_TEMPO " + child->value + "\n";
                } else if (child->type == "timesig") {
                    result += "SET_TS " + child->value + "\n";
                }
            }
        }
        result += "\n";
        
        // Process statements
        if (node->children.size() > 1 && node->children[1]->type == "statements") {
            for (auto stmt : node->children[1]->children) {
                result += generateGBASM(stmt);
            }
        }
        
        result += "\nHALT\n";
        
    } else if (node->type == "statements") {
        for (auto stmt : node->children) {
            result += generateGBASM(stmt);
        }
        
    } else if (node->type == "play_note") {
        if (node->children.size() >= 4) {
            std::string instrument = node->children[0]->value;
            std::string pitch = node->children[1]->value;
            int velocity = static_cast<int>(std::stod(node->children[2]->value));
            std::string durationStr = node->children[3]->value;
            
            int trackID = getTrackID(instrument);
            int midiNote = pitchToMIDI(pitch);
            int duration = durationToTicks(durationStr);
            
            result += "TRACK " + std::to_string(trackID) + "\n";
            result += "NOTE " + std::to_string(midiNote) + " " + std::to_string(velocity) + " " + std::to_string(duration) + "\n";
        }
        
    } else if (node->type == "play_chord") {
        if (node->children.size() >= 4) {
            std::string instrument = node->children[0]->value;
            auto pitchList = node->children[1]; // pitch_list node
            int velocity = static_cast<int>(std::stod(node->children[2]->value));
            std::string durationStr = node->children[3]->value;
            
            int trackID = getTrackID(instrument);
            int duration = durationToTicks(durationStr);
            
            result += "TRACK " + std::to_string(trackID) + "\n";
            result += "CHORD " + std::to_string(pitchList->children.size());
            
            for (auto pitch : pitchList->children) {
                int midiNote = pitchToMIDI(pitch->value);
                result += " " + std::to_string(midiNote);
            }
            
            result += " " + std::to_string(velocity) + " " + std::to_string(duration) + "\n";
        }
        
    } else if (node->type == "play_drum") {
        if (node->children.size() >= 4) {
            std::string drumType = node->children[1]->value;
            int velocity = static_cast<int>(std::stod(node->children[2]->value));
            std::string durationStr = node->children[3]->value;
            
            int drumID = getDrumID(drumType);
            int duration = durationToTicks(durationStr);
            
            result += "TRACK 2\n";
            result += "DRUM " + std::to_string(drumID) + " " + std::to_string(velocity) + " " + std::to_string(duration) + "\n";
        }
        
    } else if (node->type == "wait") {
        if (node->children.size() > 0) {
            std::string durationStr = node->children[0]->value;
            int ticks = durationToTicks(durationStr);
            result += "WAIT " + std::to_string(ticks) + "\n";
        }
        
    } else if (node->type == "loop_stmt") {
        static int loop_counter = 0;
        std::string loop_label = "LOOP_" + std::to_string(loop_counter++);
        
        result += "; Loop statement\n";
        if (node->children.size() > 0 && node->children[0]->type == "number") {
            int count = static_cast<int>(std::stod(node->children[0]->value));
            result += "LOAD R1 " + std::to_string(count) + "\n";
        } else {
            result += "LOAD R1 1\n";
        }
        
        result += ":" + loop_label + "\n";
        
        // Process loop body
        if (node->children.size() > 1 && node->children[1]->type == "statements") {
            for (auto body_stmt : node->children[1]->children) {
                // Explicitly handle each statement type within the loop body
                if (body_stmt->type == "play_note") {
                    std::string instrument = body_stmt->children[0]->value;
                    std::string pitch = body_stmt->children[1]->value;
                    int velocity = static_cast<int>(std::stod(body_stmt->children[2]->value));
                    std::string durationStr = body_stmt->children[3]->value;
                    
                    int trackID = getTrackID(instrument);
                    int midiNote = pitchToMIDI(pitch);
                    int duration = durationToTicks(durationStr);
                    
                    result += "TRACK " + std::to_string(trackID) + "\n";
                    result += "NOTE " + std::to_string(midiNote) + " " + std::to_string(velocity) + " " + std::to_string(duration) + "\n";
                    
                } else if (body_stmt->type == "play_chord") {
                    std::string instrument = body_stmt->children[0]->value;
                    auto pitchList = body_stmt->children[1];
                    int velocity = static_cast<int>(std::stod(body_stmt->children[2]->value));
                    std::string durationStr = body_stmt->children[3]->value;
                    
                    int trackID = getTrackID(instrument);
                    int duration = durationToTicks(durationStr);
                    
                    result += "TRACK " + std::to_string(trackID) + "\n";
                    result += "CHORD " + std::to_string(pitchList->children.size());
                    
                    for (auto pitch : pitchList->children) {
                        int midiNote = pitchToMIDI(pitch->value);
                        result += " " + std::to_string(midiNote);
                    }
                    
                    result += " " + std::to_string(velocity) + " " + std::to_string(duration) + "\n";
                    
                } else if (body_stmt->type == "play_drum") {
                    std::string drumType = body_stmt->children[1]->value;
                    int velocity = static_cast<int>(std::stod(body_stmt->children[2]->value));
                    std::string durationStr = body_stmt->children[3]->value;
                    
                    int drumID = getDrumID(drumType);
                    int duration = durationToTicks(durationStr);
                    
                    result += "TRACK 2\n";
                    result += "DRUM " + std::to_string(drumID) + " " + std::to_string(velocity) + " " + std::to_string(duration) + "\n";
                    
                } else if (body_stmt->type == "wait") {
                    std::string durationStr = body_stmt->children[0]->value;
                    int ticks = durationToTicks(durationStr);
                    result += "WAIT " + std::to_string(ticks) + "\n";
                }
            }
        }
        
        result += "DECJNZ R1 " + loop_label + "\n";
    }
    
    return result;
}

int main(int argc, char* argv[]) {
    if (argc != 4 || std::string(argv[2]) != "-o") {
        std::cerr << "Uso: " << argv[0] << " <arquivo.band> -o <arquivo.gbasm>" << std::endl;
        return 1;
    }
    
    std::string inputFile = argv[1];
    std::string outputFile = argv[3];
    
    // Open input file
    yyin = fopen(inputFile.c_str(), "r");
    if (!yyin) {
        std::cerr << "Erro: Não foi possível abrir " << inputFile << std::endl;
        return 1;
    }
    
    std::cout << "Compilando " << inputFile << " -> " << outputFile << std::endl;
    
    // Parse
    if (yyparse() != 0 || !root) {
        std::cerr << "Erro: Falha na análise sintática" << std::endl;
        fclose(yyin);
        return 1;
    }
    
    fclose(yyin);
    
    // Generate GBASM
    std::string gbasm = generateGBASM(root);
    
    // Write output
    std::ofstream outFile(outputFile);
    if (!outFile) {
        std::cerr << "Erro: Não foi possível criar " << outputFile << std::endl;
        return 1;
    }
    
    outFile << gbasm;
    outFile.close();
    
    std::cout << "✓ GBASM gerado com sucesso: " << outputFile << std::endl;
    
    delete root;
    return 0;
}
